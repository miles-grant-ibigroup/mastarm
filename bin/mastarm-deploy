#!/usr/bin/env node

const path = require('path')

const commander = require('commander')
const execa = require('execa')
const origin = require('git-remote-origin-url')
const repoInfo = require('git-repo-info')
const commit = require('this-commit')()
const username = require('username')

const build = require('../lib/build')
const {readFile, writeFile} = require('../lib/fs-promise')
const loadConfig = require('../lib/load-config')
const logger = require('../lib/logger')
const pkg = require('../lib/pkg')
const createPushToS3 = require('../lib/push-to-s3')
const util = require('../lib/util')
const mastarmVersion = require('../package.json').version

commander
  .option(
    '-c, --config <path>',
    'Path to configuration files.',
    path.join(process.cwd(), '/configurations/default')
  )
  .option('-e, --env <environment>', 'Environment to use.')
  .option('-m, --minify', 'Minify built files.')
  .option('-O, --outdir <dir>', 'Publish directory', '')
  .option('--cloudfront', 'CloudFront Distribution ID to invalidate.')
  .option('--s3bucket', 'S3 Bucket to push to.')
  .parse(process.argv)

// each of these variables are also used in the logToMsTeams function and
// these need to be defined after potentially decoding a sops-encoded file
let cloudfront, config, env, minify, s3bucket, tag, url

async function deploy () {
  // get information about the config directory being used
  const repoUrl = await origin(commander.config)
  let configCommit, configRemoteUrl
  const configRepoRoot = repoInfo(commander.config).root
  const configDir = path
    .resolve(commander.config)
    .replace(configRepoRoot, '')

  // check if the config directory being used is a configurations repo
  if (repoUrl.endsWith('/configurations.git')) {
    // run some extra checks to make sure configurations repo is up to date
    // modified from https://stackoverflow.com/a/3278427/269834
    configRemoteUrl = repoUrl.replace('.git', '')
    const { stdout: local } = await execa('git', ['-C', configRepoRoot, 'rev-parse', '@'])
    const { stdout: remote } = await execa('git', ['-C', configRepoRoot, 'rev-parse', '@{u}'])
    const { stdout: base } = await execa('git', ['-C', configRepoRoot, 'merge-base', '@', '@{u}'])
    let configurationsOk = false
    if (local === remote) {
      // Up-to-date
      console.log('Configurations up-to-date')
      configurationsOk = true
    } else if (local === base) {
      console.error('Configurations out of sync: Need to pull')
    } else if (remote === base) {
      console.error('Configurations out of sync: Need to push')
    } else {
      console.error('Configurations out of sync: Diverged')
    }

    // make sure there are no changes to the configurations
    const { stdout: status } = await execa(
      'git',
      [
        '-C',
        configRepoRoot,
        'status',
        '-s'
      ]
    )
    if (status === '') {
      console.log('No changes to configurations repo')
    } else {
      console.error('Configurations out of sync: local changes exist that are not yet committed')
      configurationsOk = false
    }

    if (!configurationsOk) process.exit(1)

    configCommit = local

    // decrypt env file using sops to make sure old file is overwritten with
    // data from encoded sops file
    const configPath = path.resolve(commander.config)
    console.log('decrypting env file with sops')
    const {stdout} = await execa(
      'sops',
      [
        '-d',
        path.join(configPath, 'env.enc.yml')
      ]
    )
    await writeFile(path.join(configPath, 'env.yml'), stdout)
    // at this point, we can be certain that the local configurations repo
    // directory matches what has been committed and pushed to the remote repo
  }

  url = pkg.repository.url.replace('.git', '')
  tag = `<${url}/commit/${commit}|${pkg.name}@${commit.slice(0, 6)}>`
  config = loadConfig(process.cwd(), commander.config, commander.env)
  const get = util.makeGetFn([commander, config.settings])

  if (config.env.SLACK_WEBHOOK && config.env.SLACK_WEBHOOK.length > 0) {
    logger.logToSlack({
      channel: config.env.SLACK_CHANNEL || '#devops',
      webhook: config.env.SLACK_WEBHOOK
    })
  }

  const files = util.parseEntries([...commander.args, ...(get('entries') || [])])
  util.assertEntriesExist(files)
  const sourceFiles = files.map(f => f[0])
  const outfiles = [...files.map(f => f[1]), ...files.map(f => `${f[1]}.map`)]

  env = get('env') || 'development'
  minify = get('minify')
  const buildOpts = {
    config,
    env,
    files,
    minify
  }
  cloudfront = get('cloudfront')
  s3bucket = get('s3bucket')

  const pushToS3 = createPushToS3({
    cloudfront,
    s3bucket
  })

  await logger.log(
    `:construction: *deploying: ${tag} by <@${username.sync()}>*
    :vertical_traffic_light: *mastarm:* v${mastarmVersion}
    :cloud: *cloudfront:* ${cloudfront}
    :hash: *commit:* ${commit}
    :seedling: *env:* ${env}
    :compression: *minify:* ${minify}
    :package: *s3bucket:* ${s3bucket}
    :hammer_and_wrench: *building:* ${sourceFiles.join(', ')}`
  )

  try {
    await build(buildOpts)
    await logger.log(`:rocket: *uploading:* ${sourceFiles.length * 2} file(s)`)
    await Promise.all(
      outfiles.map(outfile =>
        readFile(outfile).then(body => pushToS3({body, outfile}))
      )
    )
    await logger.log(
      `:tada: :confetti_ball: :tada: *deploy ${tag} complete* :tada: :confetti_ball: :tada:`
    )
    await logToMsTeams({ configCommit, configDir, configRemoteUrl })
    process.exit(0)
  } catch (error) {
    await logger.log(
      `:rotating_light: *${tag} error deploying ${tag} ${error.message || error}*`
    )
    await logToMsTeams({ configCommit, configDir, configRemoteUrl, error })
    process.exit(1)
  }
}

deploy()

/**
 * Sends a card to MS Teams with information about the deployment
 * @param  {[string]} configCommit   hash of the commit in the configurations
 *                          repo (if it exists)
 * @param  {[string]} configDir   partial path to specific config directory used
 *                          to deploy
 * @param  {[string]} configRemoteUrl base url for the configurations repo
 *                          (if it exists)
 * @param  {[Error]} error the error, if one occurred. A falsy value indicates
 *                          success
 */
function logToMsTeams ({ configCommit, configDir, configRemoteUrl, error }) {
  if (!config.env.MS_TEAMS_WEBHOOK) return Promise.resolve()

  const potentialAction = [{
    '@type': 'OpenUri',
    name: `View Commit on Github`,
    targets: [
      {
        os: 'default',
        uri: `${url}/commit/${commit}`
      }
    ]
  }]
  if (configCommit && configRemoteUrl) {
    potentialAction.push({
      '@type': 'OpenUri',
      name: `View Config Commit on Github`,
      targets: [
        {
          os: 'default',
          uri: `${configRemoteUrl}/tree/${configCommit}/${configDir}`
        }
      ]
    })
  }
  const text = `üìÑ *commit:* ${pkg.name}@${commit.slice(0, 6)}\n
  üë§ *deployed by:* ${username.sync()}\n
  ${configCommit
    ? `üéõÔ∏è *config:* configurations@${configCommit.slice(0, 6)}\n
  üìÇ *config folder:* ${configDir}\n` // improper indenting here needed to properly format on MS Teams
    : 'üéõÔ∏è *config:* unknown configuration data!\n'}
  üö¶ *mastarm:* v${mastarmVersion}\n
  ‚òÅÔ∏è *cloudfront:* ${cloudfront}\n
  üå± *env:* ${env}\n
  üóúÔ∏è *minify:* ${minify}\n
  üì¶ *s3bucket:* ${s3bucket}\n
  ${error
    ? `üö® üö® *error deploying ${error.message || error}*`
    : `üéâ üéä üéâ *deploy successful!* üéâ üéä üéâ`}`

  return logger.notifyMsTeams({
    potentialAction,
    text,
    title: `${error ? 'Failed to deploy' : 'Successfully deployed'} ${pkg.name}`,
    webhook: config.env.MS_TEAMS_WEBHOOK
  })
}
