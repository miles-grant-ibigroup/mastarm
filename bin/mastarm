#!/usr/bin/env node

const commander = require('commander')
const path = require('path')

const loadConfig = require('../lib/load-config')
const util = require('../lib/util')

commander
  .version(require('../package.json').version)
  .option('-c, --config <path>', 'Path to configuration files.', path.join(process.cwd(), '/configurations/default'))
  .option('-e, --env <environment>', 'Environment to use.', process.env.NODE_ENV || 'development')
  .option('-m, --minify', 'Minify built files.')
  .option('-S, --skip-check-dependencies', 'Skip checking and installing out of date package.json dependencies.')

commander
  .command('build [entries...]')
  .description('Bundle JavaScript & CSS')
  .option('-F, --flyle', 'Cache and serve tiles.')
  .option('-p, --proxy <address>', 'Proxy calls through to target address.')
  .option('-s, --serve', 'Serve with budo. Auto-matically rebuilds on changes.')
  .option('-w, --watch', 'Automatically rebuild on changes.')
  .action(function (entries, options) {
    checkDependencies()
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])
    const files = util.parseEntries(entries, get)
    if (files.length === 0) {
      console.log('No entry point found!  Did you spell the filename correctly?')
      process.exit(1)
    }
    if (get('serve')) {
      const budo = require('../lib/budo')
      budo({
        config,
        files,
        flyle: get('flyle'),
        proxy: get('proxy')
      })
    } else {
      const build = require('../lib/build')
      build({
        config,
        env: get('env'),
        files,
        minify: get('minify'),
        watch: get('watch')
      })
    }
  })

commander
  .command('commit')
  .description('Force intelligent commit messages.')
  .action(function () {
    util.popMastarmFromArgv()
    const path = require('path')
    const bootstrap = require('commitizen/dist/cli/git-cz').bootstrap
    bootstrap({
      cliPath: path.join(__dirname, '../node_modules/commitizen'),
      config: {
        path: 'cz-conventional-changelog'
      }
    })
  })

commander
  .command('deploy [entries...]')
  .description('Bundle & Deploy JavaScript & CSS')
  .option('--cloudfront', 'CloudFront Distribution ID to invalidate.')
  .option('--s3bucket', 'S3 Bucket to push to.')
  .action(function (entries, options) {
    checkDependencies()
    const pushToS3 = require('../lib/push-to-s3')
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])
    const files = util.parseEntries(entries, get)
    if (files.length === 0) {
      console.log('No file(s) found!  Did you spell the filename correctly?')
      process.exit(1)
    }
    files.map(pushToS3({
      cloudfront: get('cloudfront'),
      config,
      env: get('env'),
      minify: get('minify'),
      s3bucket: get('s3bucket')
    }))
  })

commander
  .command('lint')
  .allowUnknownOption()
  .description('Lint JavaScript [& CSS coming soon!]')
  .action(function () {
    const engine = require('standard-engine')
    const standardOptions = require('standard/options')
    // get lint out of there
    process.argv = process.argv.filter((arg) => arg !== 'lint')
    // Force verbose
    process.argv.push('--verbose')
    // add babel-eslint parser
    standardOptions.parser = 'babel-eslint'
    engine.cli(standardOptions)
  })

commander
  .command('prepublish [entries...]')
  .description('Transpile JavaScript down to ES5 with Babel')
  .action(function (entries) {
    checkDependencies()
    const babel = require('babel-core')
    const fs = require('fs')
    const glob = require('glob')
    const mkdirp = require('mkdirp')
    const outdir = path.join(process.cwd(), 'build')
    const options = {
      presets: [
        require('babel-preset-es2015'),
        require('babel-preset-react'),
        require('babel-preset-stage-0')
      ],
      plugins: [
        require('babel-plugin-add-module-exports'),
        require('babel-plugin-transform-runtime')
      ],
      sourceMaps: true
    }
    entries.forEach((entry) => {
      if (fs.statSync(entry).isDirectory()) {
        transformDir(entry)
      } else {
        transformFile(entry)
      }
    })
    function transformFile (filename) {
      const filepath = path.join(outdir, filename)
      const results = babel.transform(
        fs.readFileSync(filename, 'utf8'),
        Object.assign({}, options, {filename})
      )
      mkdirp.sync(path.dirname(filepath))
      fs.writeFileSync(filepath, results.code + '\n//# sourceMappingURL=' + path.basename(filepath))
      fs.writeFileSync(`${filepath}.map`, JSON.stringify(results.map))
    }
    function transformDir (dir) {
      glob(`${dir}/**/*.js`, (err, files) => {
        if (err) console.error(err)
        files.forEach(transformFile)
      })
    }
  })

commander
  .command('test [patterns...]')
  .description('Run tests using Jest')
  .option('-u, --update-snapshots', 'Force update of snapshots.  USE WITH CAUTION.')
  .option('--coverage', 'Run Jest with coverage reporting')
  .option('--no-cache', 'Run Jest with cache')
  .option('--coverage-paths <paths>', 'Extra paths to collect code coverage from')
  .option('--setup-files <paths>', 'Setup files to run before each test')
  .action(function (patterns, options) {
    checkDependencies()
    const jest = require('jest')
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const testUtils = require('../lib/test')
    testUtils.setupTestEnvironment(config)
    jest.run(testUtils.generateTestConfig(patterns, options))
  })

commander.parse(process.argv)

function checkDependencies () {
  if (!commander.skipCheckDependencies) {
    const results = util.updateDependencies()
    if (results.status !== 0) {
      console.error(results.error)
      process.exit(results.status)
    } else if (!results.depsWereOk) {
      console.log('Updated out of date dependencies found in package.json. Please try running the command again.')
      process.exit(results.status)
    }
  }
}
